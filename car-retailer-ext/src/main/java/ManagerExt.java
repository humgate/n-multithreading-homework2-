/**
 * Менеджер автосалона.
 * - Продает автомобиль клиенту.
 * - Получает новый автомобиль поставленный производителем. Сюда же включено время производства
 * автомобиля производителем.
 *
 * В предложенном мной решении совмещено производство автомобиля производителем и приемка его
 * в салон менеджером - в методе receiveCar(). В моем решении считаем, что на заводе-изготовителе к моменту начала
 * нашей задачи уже изготовлено достаточно автомобилей для всех и вопрос возможности продажи автомобиля покупателю
 * зависит только, от наличия авто на складе салона, которое в свою очередь определяется расторопностью менеджера
 * по приемке авто. Это вполне оправдано с точки зрения тестового задания и освоения темы, хотя не соответствует
 * в точности условиям задания.
 * Если же дословно выполнять условия задачи, то необходимо реализовывать производителя авто отдельной сущностью
 * от салона. Произведенные производителем автомобили сначала складывать на склад производителя, затем
 * отдельными потоками переносить их со склада производителя на склад салона.
 * Я полагаю, что судя по отсылкам к примеру лекции, автор задания не требует реализации производства полностью
 * отвязанного от салона (поставки). Если же я не прав, и это действительно требуется, то просьба сообщить - будем
 * переписывать
 *
 */
public class ManagerExt {
    //имя
    private String name;

    //время в миллисекундах на производство и получение менеджером нового авто от производителя
    private final int NEW_CAR_PROD_TIME = 2000;

    //время оформления продажи автомобиля
    private final int CAR_ORDER_TIME = 500;

    //количество машин которое должен произвести производитель
    private final int CARS_TO_BUILD = 10;

    //салон в котором работает менеджер
    private final CarRetailerExt carRetailerExt;

    public ManagerExt(CarRetailerExt carRetailerExt, String name) {
        this.carRetailerExt = carRetailerExt;
        this.name = name;
    }

    @Override
    public String toString() {
        return "Менеджер " + name;
    }

    /**
     * Получает новый автомобиль от производителя и помещает его на склад салона.
     * Внутрь данной операции включено время производства производителем.
     * synchronized не по менеджеру, а по салону (по складу салона).
     *
     * Логика здесь следующая: в нашем салоне будет работать более одного менеджера. Поэтому неправильно будет
     * синхронизировать потоки по менеджеру. Если так сделать, то поток-покупатель, наткнувшись на отсутствие машин,
     * будет ждать когда исключительно ТОТ ЖЕ менеджер, который занимался продажей ему, примет на склад авто от
     * производителя. А нам как раз это не нужно. Мы наняли специально двух менеджеров, чтобы любой из них мог
     * продавать новые машины и третьего, который будет только принимать их у завода.
     *
     * Объектом-монитором должен стать склад салона (в нашем случае сам салон).
     * Только один поток может продавать машину со склада или помещать ее туда от производителя.
     * Поскольку и операция продажи и операция пополнения склада требуют доступа к складу, который синхронизирован,
     * можно не бояться ситуации гонки потоков в отношении менеджера
     */
    public void receiveCar() {
        for (int i = 0; i < CARS_TO_BUILD; i++) {
            try {
                Thread.sleep(NEW_CAR_PROD_TIME);
                System.out.println(Thread.currentThread().getName() + ": Произведен новый автомобиль");

                carRetailerExt.doLock(); //используем вместо начала synchronized
                carRetailerExt.receiveCar(new Car());
                System.out.println(Thread.currentThread().getName() + ": автомобиль принят " + this);
                carRetailerExt.doNotifyAll(); //используем вместо notifyAll

            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                carRetailerExt.doUnlock(); //используем вместо конца synchronized
            }
        }
    }

    /**
     * Продажа автомобиля со склада салона.
     *
     * synchronized не по менеджеру, а по салону (по складу салона).
     *
     * Логика здесь следующая: в нашем салоне будет работать более одного менеджера. Поэтому неправильно будет
     * синхронизировать потоки по менеджеру. Если так сделать, то поток-покупатель, наткнувшись на отсутствие машин,
     * будет ждать когда исключительно ТОТ ЖЕ менеджер, который занимался продажей ему, примет на склад авто от
     * производителя. А нам как раз это не нужно, мы наняли специально двух менеджеров чтобы любой из них мог
     * принимать новые машины и третьего который будет только принимать из у завода.
     *
     * Объектом-монитором должен стать склад салона (в нашем случае сам салон).
     * Только один поток может продавать машину со склада или помещать ее туда от производителя.
     * Поскольку и операция продажи и операция пополнения склада требуют доступа к складу, который синхронизирован,
     * можно не бояться ситуации гонки потоков в отношении менеджера
     */
    public void sellCar() {
        System.out.println(Thread.currentThread().getName() + " пришел покупать авто");
        carRetailerExt.doLock(); //используем вместо начала synchronized
        try {
            while (carRetailerExt.getFromStore() == null) {
                System.out.println(this + ": Нет машин на складе");
                carRetailerExt.doAwait(); //используем вместо wait
            }
            Thread.sleep(CAR_ORDER_TIME);
            System.out.println(this + ": Продал машину со склада покупателю " + Thread.currentThread().getName());
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            carRetailerExt.doUnlock(); //используем вместо конца synchronized
        }
    }
}
